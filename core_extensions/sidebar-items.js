window.SIDEBAR_ITEMS = {"attr":[["macro_attr","For using function-like macros as attributes."]],"enum":[["Void","Type for impossible situations."]],"macro":[["compile_error_stringify","Stringifies the input tokens, and errors with `compile_error`."],["count_tts","Counts the amount of token trees passed to this macro, passing the amount to an (optional) callback macro."],["gen_ident_range","Generates identifiers. passing them to a callback macro."],["iter_cloner","Use this macro to create an `IterCloner` from an `IntoIterator` (this includes all `Iterator`s)."],["matches","Evaluates to true if the expression matches any of the patterns (this macro can have multiple patterns)."],["parenthesize_args","Adaptor macro which passes arguments to a callback macro, wrapping them in parentheses."],["rewrap_macro_parameters","Rewraps the tokens inside macro parameters into parentheses."],["tokens_method","Does slice and iterator operations on tokens, passing the result to a callback macro."]],"mod":[["iterators","Iterator adaptors and constructors."],["measure_time","Time measurement."],["slices","Slice extension traits, and related items."],["strings","Extension trait for string types."],["type_asserts","Type-level assertions, most useful for tests."],["type_level_bool","Type level booleans"],["utils","Miscelaneous utility functions"]],"trait":[["SelfOps","Extension trait for every type."],["TypeIdentity","Allows converting `Self` to `Self::Type` by proving that both types are equal."]],"type":[["TIdentity","A type-level identity function"]]};